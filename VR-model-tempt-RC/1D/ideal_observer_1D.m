% ----------------------------------------------------------------------
% ideal_observer_1D.m
% 1D ideal observer model for all 9 targets and all penalty directions.
% ----------------------------------------------------------------------
% Notes: 
% 1D: aims points searched along penalty axis only..
% Endpoints sampled with Monte Carlo Sampling (mvnrnd)
% Mike's note:
% Expected gain calculation:
%   EG = proportion_hit_target * value_target
%      + proportion_hit_penalty * value_penalty
% Endpoints in the overlap zone contribute to BOTH terms automatically.
% ----------------------------------------------------------------------
% Input(s) :
% empirical_cov_results.mat
% 'SigmaByCond' 
% 'NByCond'
% ----------------------------------------------------------------------
% Output(s):
% ideal_observer_1D_results.mat
% figures
% ----------------------------------------------------------------------
% Function created by Rachel Chen (qc898@nyu.edu)
% Last update : 2026-02-24
% Project : VR
% Version : 3.0
% ----------------------------------------------------------------------

clear; close all; clc;

%% ========== PARAMETERS (should be consistent with Unity code) ====================

% Gain structure (two zones only):
value_target  =  300;   
value_penalty = -500;   

% Geometries (unit: mm)
% Target
t_radius = 20;        % Target sphere radius (RewardEvaluator.cs: 0.02m)
n_target = 9;

% Target center coordinates (mm) （from TargetController.cs）：
% TARGET{1} = [-100,  900, 2441];   % T1: bottom-left
% TARGET{2} = [   0,  900, 2473];   % T2: bottom-center
% TARGET{3} = [ 100,  900, 2441];   % T3: bottom-right
% TARGET{4} = [-100, 1000, 2473];   % T4: center-left
% TARGET{5} = [   0, 1000, 2500];   % T5: center-center
% TARGET{6} = [ 100, 1000, 2473];   % T6: center-right
% TARGET{7} = [-100, 1100, 2441];   % T7: top-left
% TARGET{8} = [   0, 1100, 2473];   % T8: top-center
% TARGET{9} = [ 100, 1100, 2441];   % T9: top-right
% However, all computations are relative to target center, so absolute coordinates
% are not needed. 

t_center = [0, 0, 0];

% Penalty
penalty_edge = 0;     % Distance from target center to nearest penalty edge

% Penalty box:1000x1000x100mm, penalty edge is at target center
% Notes: For penalty on +X direction: center = target + (500, 0, 0) mm
% box extends from target_x + 0 to target_x + 1000 mm along X
penalty_width = 1000;

%% ========== Monte Carlo settings ====================

n_samples = 100000;

% number of BADS runs per condition
n_bads_runs = 5; 

% 1D aimpoint search range (mm)
axis_range = 60;     

% Plotting settings
n_plot_points = 200;  % number of points for EG curve

%% ========== PENALTY CONDITIONS ====================

% ---- Which penalty axis was tested in the current dataset? ----
penalty_axis_tested = 1;  
%   1 = X axis (left/right)   — PenaltyIndex 1 & 2
%   2 = Y axis (up/down)      — PenaltyIndex 3 & 4
%   3 = Z axis (forward/back) — PenaltyIndex 5 & 6

% ---- Full penalty condition table ----
% Each row: [penalty_axis, penalty_sign]
% Notations from PenaltyControllerLR.cs:
%   1=left(-X), 2=right(+X), 3=up(+Y), 4=down(-Y), 5=forward(+Z), 6=back(-Z)
all_penalty_conditions = [
    1, -1;   % PenaltyIndex 1: left   (-X)
    1,  1;   % PenaltyIndex 2: right  (+X)
    2,  1;   % PenaltyIndex 3: up     (+Y)
    2, -1;   % PenaltyIndex 4: down   (-Y)
    3,  1;   % PenaltyIndex 5: forward(+Z)
    3, -1;   % PenaltyIndex 6: back   (-Z)
];

all_penalty_labels = {'Left (-X)', 'Right (+X)', 'Up (+Y)', 'Down (-Y)', 'Forward (+Z)', 'Back (-Z)'};
axis_names = {'X', 'Y', 'Z'};

% Filter to only the penalty conditions matching the tested axis
tested_mask = all_penalty_conditions(:,1) == penalty_axis_tested;
penalty_conditions = all_penalty_conditions(tested_mask, :);
penalty_labels = all_penalty_labels(tested_mask);

% Chekc
fprintf('Penalty axis tested: %s\n', axis_names{penalty_axis_tested});
fprintf('Penalty conditions: %s, %s\n', penalty_labels{1}, penalty_labels{2});

%% ================= LOAD DATA =================
% Using empirial covariance matrix generated by luhe's cov_from_reachingdata.m
load('empirical_cov_results.mat', 'SigmaByCond', 'NByCond');

% ConditionID mapping (note: 1-indexed in MATLAB):
%   ConditionID = TargetIndex * 3 + PenaltyIndex

% No-penalty conditions(PenaltyIndex=0) 
% Indexes in MATLAB: 1, 4, 7, 10, 13, 16, 19, 22, 25
no_penalty_cond_idx = 1:3:25;  


% Extract covariance for each target (no-penalty only)
COV = cell(1, n_target);
for ii = 1:n_target
    COV{ii} = SigmaByCond(:,:, no_penalty_cond_idx(ii)) * 1e6;  % m^2 -> mm^2
end

% Check
fprintf('Trial counts per target (no-penalty):\n');
for ii = 1:n_target
    fprintf('  Target %d: %d trials\n', ii, NByCond(no_penalty_cond_idx(ii)));
end
fprintf('\n');

%% ========== COMPUTE OPTIMAL (BADS) SHIFT FOR EACH TARGET x PENALTY ===========
% Mike's note (LOL):
% For each possible 3-d aimpoint:
%   1. Generate thousands of sample endpoints (from mvnrnd(aimpoint,
%      empirical_cov))
%   2. Calculate the proportion of those endpoints that landed inside the target 
%      (i.e., had a distance from the target center that was less than or equal to the target radius)
%   3. Calculate the proportion of those endpoints that landed inside the penalty 
%      (e.g., that had an x-value less than the x-value of the penalty plane, for the penalty-on-the-right condition)
%   4. Calculate expected gain as proportiontarget*valuetarget + proportionpenalty*valuepenalty

% Note:
% Should pass negative EG

n_penalty_cond = size(penalty_conditions, 1);

opt_shift = zeros(n_target, n_penalty_cond);
opt_aim   = zeros(n_target, n_penalty_cond, 3);  % full 3D aimpoint
max_eg    = zeros(n_target, n_penalty_cond);

for pp = 1:n_penalty_cond
    p_axis = penalty_conditions(pp, 1);   % x/y/z?
    p_sign = penalty_conditions(pp, 2);   % left/right?

    for ii = 1:n_target

        cov_matrix = COV{ii};

        % check to be negative
        neg_eg_fun = @(shift) compute_neg_eg(shift, t_center, cov_matrix, ...
            p_axis, p_sign, t_radius, penalty_edge, ...
            value_target, value_penalty, n_samples);

        % BADS bounds for 1D shift
        lb  = -axis_range;      % hard lower bound
        ub  =  axis_range;      % hard upper bound
        plb = -axis_range/2;    % plausible lower bound
        pub =  axis_range/2;    % plausible upper bound

        % BADS part
        best_shift = 0;
        best_neg_eg = inf;

        start_points = linspace(plb, pub, n_bads_runs);

        for rr = 1:n_bads_runs
            [x_opt, fval] = bads(neg_eg_fun, start_points(rr), lb, ub, plb, pub);
            if fval < best_neg_eg
                best_neg_eg = fval;
                best_shift = x_opt;
            end
        end

        opt_shift(ii, pp) = best_shift;
        opt_aim(ii, pp, :) = t_center;
        opt_aim(ii, pp, p_axis) = best_shift;
        max_eg(ii, pp) = -best_neg_eg;

        fprintf('  Target %d, %s: shift=%+.2f mm, EG=%.1f\n', ...
            ii, penalty_labels{pp}, best_shift, -best_neg_eg);
    end

    %fprintf('Finished penalty condition: %s\n\n', penalty_labels{pp});
end

%% ========== DISPLAY RESULTS ==========================================

fprintf('\n=============== 1D Ideal Observer Results (Monte Carlo) ===============\n');

for pp = 1:n_penalty_cond
    p_axis = penalty_conditions(pp, 1);
    fprintf('--- %s ---\n', penalty_labels{pp});

    for ii = 1:n_target
        sigma = sqrt(COV{ii}(p_axis, p_axis));
        fprintf('  Target %d: sigma_%s=%.2f mm, optimal shift=%+.2f mm, EG=%.1f\n', ...
            ii, axis_names{p_axis}, sigma, opt_shift(ii,pp), max_eg(ii,pp));
    end
    fprintf('\n');
end

%% ========== PLOT 1: Optimal shift vs marginal SD =======================

figure('Position', [50, 50, 800, 400]);
sgtitle(sprintf('1D Ideal Observer: Optimal Shift vs Marginal SD (%s axis)', ...
    axis_names{penalty_axis_tested}), 'FontSize', 16, 'FontWeight', 'bold');

for pp = 1:n_penalty_cond
    p_axis = penalty_conditions(pp, 1);

    subplot(1, n_penalty_cond, pp); hold on;

    sigmas = zeros(n_target, 1);
    for ii = 1:n_target
        sigmas(ii) = sqrt(COV{ii}(p_axis, p_axis));
    end

    scatter(sigmas, abs(opt_shift(:, pp)), 80, 'filled');
    for ii = 1:n_target
        text(sigmas(ii) + 0.05, abs(opt_shift(ii, pp)) + 0.05, sprintf('T%d', ii), 'FontSize', 9);
    end

    xlabel(sprintf('Marginal SD on %s (mm)', axis_names{p_axis}));
    ylabel('|Optimal shift| (mm)');
    title(penalty_labels{pp});
    grid on;
end

set(findall(gcf, '-property', 'FontSize'), 'FontSize', 12);
saveas(gcf, 'ideal_1D_shift_vs_sigma.png');

%% ========== PLOT 2: EG landscape for one example target ================

example_target = 5;  % middle target (T5)
example_penalty = find(penalty_conditions(:,2) == 1, 1);  % let's just see the positive direction
if isempty(example_penalty); example_penalty = 1; end

p_axis = penalty_conditions(example_penalty, 1);
p_sign = penalty_conditions(example_penalty, 2);

t_center_ex = t_center;
cov_ex = COV{example_target};
sigma_ex = sqrt(cov_ex(p_axis, p_axis));

shifts_ex = linspace(-axis_range, axis_range, n_plot_points);
eg_ex = zeros(size(shifts_ex));

for aa = 1:length(shifts_ex)
    eg_ex(aa) = -compute_neg_eg(shifts_ex(aa), t_center_ex, cov_ex, ...
        p_axis, p_sign, t_radius, penalty_edge, ...
        value_target, value_penalty, n_samples);
end

figure('Position', [100, 100, 1000, 500]);
hold on;

% Shade penalty side
yl = [min(eg_ex)*1.1, max(eg_ex)*1.1];
if yl(1) >= yl(2); yl = [-100, 300]; end

if p_sign > 0
    fill([0, axis_range, axis_range, 0], [yl(1) yl(1) yl(2) yl(2)], ...
         [1 0.8 0.8], 'EdgeColor', 'none', 'FaceAlpha', 0.3);
else
    fill([-axis_range, 0, 0, -axis_range], [yl(1) yl(1) yl(2) yl(2)], ...
         [1 0.8 0.8], 'EdgeColor', 'none', 'FaceAlpha', 0.3);
end

% EG curve
plot(shifts_ex, eg_ex, 'b-', 'LineWidth', 2);

% Mark optimal
[~, best_idx] = max(eg_ex);
plot(shifts_ex(best_idx), eg_ex(best_idx), 'ro', 'MarkerSize', 12, 'LineWidth', 2);

% Mark zero shift (target center)
xline(0, 'k--', 'LineWidth', 1.5);

ylim(yl);
xlabel(sprintf('Shift along %s (mm)', axis_names{p_axis}));
ylabel('Expected Gain');
title(sprintf('EG Landscape — Target %d, %s (\\sigma_%s=%.1f mm, shift=%+.1f mm)', ...
    example_target, penalty_labels{example_penalty}, axis_names{p_axis}, sigma_ex, ...
    opt_shift(example_target, example_penalty)));
legend({'Penalty side', 'Expected Gain', 'Optimal aim', 'Target center'}, 'Location', 'best');
grid on;
set(findall(gcf, '-property', 'FontSize'), 'FontSize', 13);
saveas(gcf, 'ideal_1D_eg_landscape.png');

%% ========== PLOT 3: All targets, one figure per penalty direction =======

target_order = [7,8,9,4,5,6,1,2,3];

for pp = 1:n_penalty_cond
    p_axis = penalty_conditions(pp, 1);
    p_sign = penalty_conditions(pp, 2);

    figure('Position', [50, 50, 1800, 1000]);
    sgtitle(sprintf('EG Landscape — all targets, %s', penalty_labels{pp}), ...
        'FontSize', 16, 'FontWeight', 'bold');

    for subplot_idx = 1:9
        ii = target_order(subplot_idx);
        subplot(3, 3, subplot_idx); hold on;

        t_center_i = t_center;
        cov_i = COV{ii};
        sigma_i = sqrt(cov_i(p_axis, p_axis));

        shifts_i = linspace(-axis_range, axis_range, n_plot_points);
        eg_i = zeros(size(shifts_i));

        for aa = 1:length(shifts_i)
            eg_i(aa) = -compute_neg_eg(shifts_i(aa), t_center_i, cov_i, ...
                p_axis, p_sign, t_radius, penalty_edge, ...
                value_target, value_penalty, n_samples);
        end

        % Shade penalty side
        yl_i = [min(eg_i)*1.1, max(eg_i)*1.1];
        if yl_i(1) >= yl_i(2); yl_i = [-100, 300]; end

        if p_sign > 0
            fill([0, axis_range, axis_range, 0], [yl_i(1) yl_i(1) yl_i(2) yl_i(2)], ...
                 [1 0.8 0.8], 'EdgeColor', 'none', 'FaceAlpha', 0.2);
        else
            fill([-axis_range, 0, 0, -axis_range], [yl_i(1) yl_i(1) yl_i(2) yl_i(2)], ...
                 [1 0.8 0.8], 'EdgeColor', 'none', 'FaceAlpha', 0.2);
        end

        plot(shifts_i, eg_i, 'b-', 'LineWidth', 1.5);
        [~, bi] = max(eg_i);
        plot(shifts_i(bi), eg_i(bi), 'ro', 'MarkerSize', 8, 'LineWidth', 1.5);
        xline(0, 'k--');

        ylim(yl_i);
        xlabel(sprintf('Shift %s (mm)', axis_names{p_axis}));
        ylabel('EG');
        title(sprintf('T%d (\\sigma_%s=%.1f, shift=%+.1f)', ii, axis_names{p_axis}, sigma_i, opt_shift(ii, pp)));
    end

    set(findall(gcf, '-property', 'FontSize'), 'FontSize', 11);
    saveas(gcf, sprintf('ideal_1D_eg_all_targets_%s.png', penalty_labels{pp}));
end

close all;

%% ========== SAVE DATA =======================================================

results.penalty_axis_tested = penalty_axis_tested;
results.penalty_conditions = penalty_conditions;
results.penalty_labels = penalty_labels;

results.params = struct('value_target', value_target, 'value_penalty', value_penalty, ...
    't_radius', t_radius, 'penalty_edge', penalty_edge, ...
    'n_samples', n_samples, 'n_bads_runs', n_bads_runs);

results.opt_shift = opt_shift;
results.opt_aim = opt_aim;
results.max_eg = max_eg;

save('ideal_observer_1D_results.mat', 'results');
fprintf('All saved! \n');
