% ----------------------------------------------------------------------
% ideal_observer_3D.m
% 3D ideal observer model for all 9 targets and all penalty directions.
% ----------------------------------------------------------------------
% Notes: 
% 3D: aimpoints searched in full 3D space (x, y, z)
% Capturing the effect of off-diagonal covariance terms.
% ----------------------------------------------------------------------
% Input(s) :
% empirical_cov_results.mat
% 'SigmaByCond' 
% 'NByCond'
% ----------------------------------------------------------------------
% Output(s):
% ideal_observer_3D_results.mat
% figures
% ----------------------------------------------------------------------
% Function created by Rachel Chen (qc898@nyu.edu)
% Last update : 2026-02-24
% Project : VR
% Version : 1.0
% ----------------------------------------------------------------------

clear; close all; clc;

%% ========== PARAMETERS (should be consistent with Unity code) ====================

% Gain structure (two zones only):
value_target  =  300;   
value_penalty = -500;   

% Geometries (unit: mm)
% Target
t_radius = 20;        % Target sphere radius (RewardEvaluator.cs: 0.02m)
n_target = 9;

% Target center coordinates (mm) （from TargetController.cs）：
% TARGET{1} = [-100,  900, 2441];   % T1: bottom-left
% TARGET{2} = [   0,  900, 2473];   % T2: bottom-center
% TARGET{3} = [ 100,  900, 2441];   % T3: bottom-right
% TARGET{4} = [-100, 1000, 2473];   % T4: center-left
% TARGET{5} = [   0, 1000, 2500];   % T5: center-center
% TARGET{6} = [ 100, 1000, 2473];   % T6: center-right
% TARGET{7} = [-100, 1100, 2441];   % T7: top-left
% TARGET{8} = [   0, 1100, 2473];   % T8: top-center
% TARGET{9} = [ 100, 1100, 2441];   % T9: top-right
% However, all computations are relative to target center, so absolute coordinates
% are not needed. 

t_center = [0, 0, 0];

% Penalty
penalty_edge = 0;     % Distance from target center to nearest penalty edge

% Penalty box:1000x1000x100mm, penalty edge is at target center
% Notes: For penalty on +X direction: center = target + (500, 0, 0) mm
% box extends from target_x + 0 to target_x + 1000 mm along X
penalty_width = 1000;

%% ========== Monte Carlo settings ====================

n_samples = 100000;

% number of BADS runs per condition
n_bads_runs = 5; 

% 3D aimpoint search range (mm)
axis_range = 60;     

%% ========== PENALTY CONDITIONS ====================

% ---- Which penalty axis was tested in the current dataset? ----
penalty_axis_tested = 1;  
%   1 = X axis (left/right)   — PenaltyIndex 1 & 2
%   2 = Y axis (up/down)      — PenaltyIndex 3 & 4
%   3 = Z axis (forward/back) — PenaltyIndex 5 & 6

% ---- Full penalty condition table ----
% Each row: [penalty_axis, penalty_sign]
% Notations from PenaltyControllerLR.cs:
%   1=left(-X), 2=right(+X), 3=up(+Y), 4=down(-Y), 5=forward(+Z), 6=back(-Z)
all_penalty_conditions = [
    1, -1;   % PenaltyIndex 1: left   (-X)
    1,  1;   % PenaltyIndex 2: right  (+X)
    2,  1;   % PenaltyIndex 3: up     (+Y)
    2, -1;   % PenaltyIndex 4: down   (-Y)
    3,  1;   % PenaltyIndex 5: forward(+Z)
    3, -1;   % PenaltyIndex 6: back   (-Z)
];

all_penalty_labels = {'Left (-X)', 'Right (+X)', 'Up (+Y)', 'Down (-Y)', 'Forward (+Z)', 'Back (-Z)'};
axis_names = {'X', 'Y', 'Z'};

% Filter to only the penalty conditions matching the tested axis
tested_mask = all_penalty_conditions(:,1) == penalty_axis_tested;
penalty_conditions = all_penalty_conditions(tested_mask, :);
penalty_labels = all_penalty_labels(tested_mask);

% Check
fprintf('Penalty axis tested: %s\n', axis_names{penalty_axis_tested});
fprintf('Penalty conditions: %s, %s\n', penalty_labels{1}, penalty_labels{2});

%% ================= LOAD DATA =================
% Using empirical covariance matrix generated by luhe's cov_from_reachingdata.m
load('empirical_cov_results.mat', 'SigmaByCond', 'NByCond');

% ConditionID mapping (note: 1-indexed in MATLAB):
%   ConditionID = TargetIndex * 3 + PenaltyIndex

% No-penalty conditions(PenaltyIndex=0) 
% Indexes in MATLAB: 1, 4, 7, 10, 13, 16, 19, 22, 25
no_penalty_cond_idx = 1:3:25;  

% Extract covariance for each target (no-penalty only)
COV = cell(1, n_target);
for ii = 1:n_target
    COV{ii} = SigmaByCond(:,:, no_penalty_cond_idx(ii)) * 1e6;  % m^2 -> mm^2
end

% Check
fprintf('Trial counts per target (no-penalty):\n');
for ii = 1:n_target
    fprintf('  Target %d: %d trials\n', ii, NByCond(no_penalty_cond_idx(ii)));
end
fprintf('\n');

%% ========== COMPUTE OPTIMAL 3D SHIFT FOR EACH TARGET x PENALTY ===========
% Unlike the 1D model which searches along penalty axis only,
% here BADS optimizes all 3 components of the aimpoint shift [dx, dy, dz].
% This allows the model to exploit off-diagonal covariance structure
% (e.g., if X and Z are correlated, the optimal shift may not be purely along X).
%
% Mike's note:
% For each possible 3-d aimpoint:
%   1. Generate thousands of sample endpoints (from mvnrnd(aimpoint, empirical_cov))
%   2. Calculate the proportion that landed inside the target 
%   3. Calculate the proportion that landed inside the penalty 
%   4. Calculate expected gain as prop_target*value_target + prop_penalty*value_penalty

% Note:
% Should pass negative EG

n_penalty_cond = size(penalty_conditions, 1);

opt_shift_3d = zeros(n_target, n_penalty_cond, 3);  % [dx, dy, dz] for each condition
max_eg       = zeros(n_target, n_penalty_cond);

for pp = 1:n_penalty_cond
    p_axis = penalty_conditions(pp, 1);   % x/y/z?
    p_sign = penalty_conditions(pp, 2);   % left/right?

    for ii = 1:n_target

        cov_matrix = COV{ii};

        % takes 1x3 shift vector, returns negative EG
        neg_eg_fun = @(shift_3d) compute_neg_eg_3D(shift_3d, t_center, cov_matrix, ...
            p_axis, p_sign, t_radius, penalty_edge, ...
            value_target, value_penalty, n_samples);

        % BADS bounds for 3D shift [dx, dy, dz]
        lb  = [-axis_range, -axis_range, -axis_range];
        ub  = [ axis_range,  axis_range,  axis_range];
        plb = [-axis_range/2, -axis_range/2, -axis_range/2];
        pub = [ axis_range/2,  axis_range/2,  axis_range/2];

        % BADS part: run multiple times with different starting points
        best_shift_3d = [0, 0, 0];
        best_neg_eg = inf;

        for rr = 1:n_bads_runs
            % Random starting point [CHECK WITH MIKE TO SEE IF THIS MAKE SENSE]
            x0 = plb + (pub - plb) .* rand(1, 3);

            [x_opt, fval] = bads(neg_eg_fun, x0, lb, ub, plb, pub);
            if fval < best_neg_eg
                best_neg_eg = fval;
                best_shift_3d = x_opt;
            end
        end

        opt_shift_3d(ii, pp, :) = best_shift_3d;
        max_eg(ii, pp) = -best_neg_eg;

        fprintf('  Target %d, %s: shift=[%+.2f, %+.2f, %+.2f] mm, EG=%.1f\n', ...
            ii, penalty_labels{pp}, best_shift_3d(1), best_shift_3d(2), best_shift_3d(3), -best_neg_eg);
    end

    %fprintf('Finished penalty condition: %s\n\n', penalty_labels{pp});
end

%% ========== DISPLAY RESULTS ==========================================

fprintf('\n=============== 3D Ideal Observer Results ===============\n');

for pp = 1:n_penalty_cond
    p_axis = penalty_conditions(pp, 1);
    fprintf('--- %s ---\n', penalty_labels{pp});

    for ii = 1:n_target
        s = squeeze(opt_shift_3d(ii, pp, :))'; %target x penalty x vector
        fprintf('  Target %d: shift=[%+.2f, %+.2f, %+.2f] mm, |shift|=%.2f mm, EG=%.1f\n', ...
            ii, s(1), s(2), s(3), norm(s), max_eg(ii,pp));
    end
    fprintf('\n');
end

%% ========== PRINT OUT AND COMPARE 1D vs 3D VALUES ==========================================
% Eyeballing sanity check...
% Can comment out

% if exist('ideal_observer_1D_results.mat', 'file')
%     res_1d = load('ideal_observer_1D_results.mat', 'results');
%     res_1d = res_1d.results;
% 
%     fprintf('\n=============== 1D vs 3D Value Comparison ===============\n');
%     for pp = 1:n_penalty_cond
%         p_axis = penalty_conditions(pp, 1);
%         fprintf('--- %s ---\n', penalty_labels{pp});
%         fprintf('  Target | 1D shift (penalty axis) | 3D shift [x, y, z]       | 3D penalty-axis shift | EG_1D   | EG_3D\n');
%         fprintf('  -------+-------------------------+---------------------------+-----------------------+---------+--------\n');
% 
%         for ii = 1:n_target
%             shift_1d = res_1d.opt_shift(ii, pp);
%             s3 = squeeze(opt_shift_3d(ii, pp, :))';
%             fprintf('  T%d     | %+.2f mm                | [%+.2f, %+.2f, %+.2f] mm | %+.2f mm              | %.1f   | %.1f\n', ...
%                 ii, shift_1d, s3(1), s3(2), s3(3), s3(p_axis), res_1d.max_eg(ii,pp), max_eg(ii,pp));
%         end
%         fprintf('\n');
%     end
% else
%     fprintf('(ideal_observer_1D_results.mat not found, skipping 1D vs 3D comparison)\n');
% end

%% ========== PLOT 1: 3D shift components ================================

figure('Position', [50, 50, 1200, 500]);
sgtitle('Optimal Shift Components (3D model)', 'FontSize', 16, 'FontWeight', 'bold');

for pp = 1:n_penalty_cond
    subplot(1, n_penalty_cond, pp); hold on;

    shifts_pp = squeeze(opt_shift_3d(:, pp, :));  % 9x3

    bar_data = shifts_pp;
    b = bar(1:n_target, bar_data);
    b(1).FaceColor = [0.85 0.33 0.1];   % X: red
    b(2).FaceColor = [0.47 0.67 0.19];  % Y: green
    b(3).FaceColor = [0.0  0.45 0.74];  % Z: blue

    xlabel('Target');
    ylabel('Optimal shift (mm)');
    title(penalty_labels{pp});
    legend({'dX', 'dY', 'dZ'}, 'Location', 'best');
    grid on;
    set(gca, 'XTick', 1:n_target);
end

set(findall(gcf, '-property', 'FontSize'), 'FontSize', 12);
saveas(gcf, 'ideal_3D_shift_components.png');


%% ========== PLOT 2: Off-penalty-axis shift magnitudes ===========================
% Notes:
% This plot is aiming to show how much the 3D optimal aimpoint deviates from the penalty axis.
% If off-diagonal covariance has no effect (i.e., x,y,z independent), |off-axis shift| should be ~0.

figure('Position', [50, 50, 800, 400]);
sgtitle('3D Ideal Observer: Off-Axis Shift Magnitude', 'FontSize', 16, 'FontWeight', 'bold');

for pp = 1:n_penalty_cond
    p_axis = penalty_conditions(pp, 1); % the axis that the current dataset is tested on
    other_axes = setdiff(1:3, p_axis); % find axiss that are not being tested

    subplot(1, n_penalty_cond, pp); hold on;

    off_axis_shift = zeros(n_target, 1);
    for ii = 1:n_target
        s = squeeze(opt_shift_3d(ii, pp, :))'; %target x penalty x vector
        off_axis_shift(ii) = norm(s(other_axes));
    end

    bar(1:n_target, off_axis_shift, 'FaceColor', [0.5 0.5 0.5]);
    xlabel('Target');
    ylabel('Off-axis |shift| (mm)');
    title(penalty_labels{pp});
    grid on;
    set(gca, 'XTick', 1:n_target);
end

set(findall(gcf, '-property', 'FontSize'), 'FontSize', 12);
saveas(gcf, 'ideal_3D_off_axis_shift.png');

close all;

%% ========== SAVE DATA=======================================================

results.penalty_axis_tested = penalty_axis_tested;
results.penalty_conditions = penalty_conditions;
results.penalty_labels = penalty_labels;

results.params = struct('value_target', value_target, 'value_penalty', value_penalty, ...
    't_radius', t_radius, 'penalty_edge', penalty_edge, ...
    'n_samples', n_samples, 'n_bads_runs', n_bads_runs);

results.opt_shift_3d = opt_shift_3d;
results.max_eg = max_eg;

save('ideal_observer_3D_results.mat', 'results');
fprintf('All saved!\n');
